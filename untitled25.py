# -*- coding: utf-8 -*-
"""Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/102Iav0risdzlPTy_geKTv3WHzzwS17bb
"""

import numpy as np

# Network configuration
n_inputs = 3
n_hidden = 2
n_outputs = 1
alpha = 0.15
iterations = 800

# Random initialization (different seed)
np.random.seed(7)
weights_input_hidden = np.random.uniform(0, 1, (n_inputs, n_hidden))
bias_hidden = np.random.uniform(0, 1, n_hidden)

weights_hidden_output = np.random.uniform(0, 1, (n_hidden, n_outputs))
bias_output = np.random.uniform(0, 1, n_outputs)

# Input sample and target
input_data = np.array([[2, 5, 4]])
target = np.array([[0.9]])

# Sigmoid activation function
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

# Training loop
for i in range(iterations):
    # Forward pass
    hidden_input = np.dot(input_data, weights_input_hidden) + bias_hidden
    hidden_output = sigmoid(hidden_input)

    final_input = np.dot(hidden_output, weights_hidden_output) + bias_output
    predicted = sigmoid(final_input)

    # Error calculation (MSE)
    error = (target - predicted) ** 2

    # Backward pass
    delta_output = (predicted - target) * predicted * (1 - predicted)
    grad_w_ho = np.dot(hidden_output.T, delta_output)
    grad_b_o = delta_output.flatten()

    delta_hidden = np.dot(delta_output, weights_hidden_output.T) * hidden_output * (1 - hidden_output)
    grad_w_ih = np.dot(input_data.T, delta_hidden)
    grad_b_h = delta_hidden.flatten()

    # Parameter update
    weights_hidden_output -= alpha * grad_w_ho
    bias_output -= alpha * grad_b_o
    weights_input_hidden -= alpha * grad_w_ih
    bias_hidden -= alpha * grad_b_h

# Final output
print("Final Predicted Value:", predicted)
print("Final Error:", error)

import tensorflow as tf
import numpy as np

# Sample training data
inputs = np.array([[2, 4, 6]], dtype=np.float32)
expected_output = np.array([[0.9]], dtype=np.float32)

# Define neural network model
nn_model = tf.keras.Sequential([
    tf.keras.layers.Dense(3, activation='sigmoid', input_dim=3),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Configure training parameters
nn_model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.1),
    loss=tf.keras.losses.MeanSquaredError()
)

# Train the model
nn_model.fit(inputs, expected_output, epochs=800, verbose=0)

# Test prediction
result = nn_model.predict(inputs)

print("Network Output:", result)

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt

# Load dataset
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

# Scale pixel values to range [0,1]
train_images = train_images.astype("float32") / 255.0
test_images = test_images.astype("float32") / 255.0

# Create neural network model
digit_model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])

# Compile the model
digit_model.compile(
    optimizer=tf.keras.optimizers.Adam(),
    loss=tf.keras.losses.SparseCategoricalCrossentropy(),
    metrics=['accuracy']
)

# Train the network
digit_model.fit(train_images, train_labels, epochs=8, verbose=0)

# User selects a test image
test_index = int(input("Enter test image index (0–9999): "))

# Show selected digit
plt.imshow(test_images[test_index], cmap="gray")
plt.title("Handwritten Digit Sample")
plt.axis("off")
plt.show()

# Make prediction
input_sample = test_images[test_index].reshape(1, 28, 28)
output = digit_model.predict(input_sample)

print("Predicted Digit:", np.argmax(output))
print("True Digit:", test_labels[test_index])

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt
# Load MNIST dataset
(X_train, y_train), (X_test, y_test) = mnist.load_data()
# Normalize pixel values
X_train = X_train / 255.0
X_test = X_test / 255.0
# Build the neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])
# Compile model
model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)
# Train the model (more epochs for better accuracy)
model.fit(X_train, y_train, epochs=10, verbose=0)
# Take user input
index = int(input("Enter an index value (0 to 9999): "))
# Display the image
plt.imshow(X_test[index], cmap='gray')
plt.title("Input Handwritten Digit")
plt.axis('off')
plt.show()
# Predict the digit
sample = X_test[index].reshape(1, 28, 28)
prediction = model.predict(sample)
print("Predicted Digit:", np.argmax(prediction))
print("Actual Digit:", y_test[index])

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt

# Load MNIST training data
(train_imgs, train_lbls), _ = mnist.load_data()

# Create combined (double-digit) images and separate labels for each digit
merged_images = []
merged_labels_left = []
merged_labels_right = []

for idx in range(4000):
    left_digit = train_imgs[idx]
    right_digit = train_imgs[idx + 2] # Using a different index for the right digit
    merged = np.concatenate((left_digit, right_digit), axis=1)
    merged_images.append(merged)
    merged_labels_left.append(train_lbls[idx])
    merged_labels_right.append(train_lbls[idx + 2])

merged_images = np.array(merged_images, dtype="float32") / 255.0
merged_labels_left = np.array(merged_labels_left)
merged_labels_right = np.array(merged_labels_right)

# Define a neural network with two outputs (one for each digit)
input_tensor = tf.keras.layers.Input(shape=(28, 56))
flatten = tf.keras.layers.Flatten()(input_tensor)
shared_dense = tf.keras.layers.Dense(96, activation='relu')(flatten)

# Output layer for the left digit
output_left = tf.keras.layers.Dense(10, activation='softmax', name='left_digit_output')(shared_dense)
# Output layer for the right digit
output_right = tf.keras.layers.Dense(10, activation='softmax', name='right_digit_output')(shared_dense)

double_digit_model = tf.keras.Model(inputs=input_tensor, outputs=[output_left, output_right])

# Compile model with two loss functions (one for each output)
double_digit_model.compile(
    optimizer=tf.keras.optimizers.Adam(),
    loss={'left_digit_output': tf.keras.losses.SparseCategoricalCrossentropy(),
          'right_digit_output': tf.keras.losses.SparseCategoricalCrossentropy()},
    metrics={'left_digit_output': 'accuracy', 'right_digit_output': 'accuracy'}
)

# Train model
double_digit_model.fit(
    merged_images,
    {'left_digit_output': merged_labels_left, 'right_digit_output': merged_labels_right},
    epochs=8,
    verbose=0
)

# User-selected test sample
test_id = int(input("Enter sample index (0–3999): "))

# Display merged image
plt.imshow(merged_images[test_id], cmap='gray')
plt.title("Double Digit Image")
plt.axis("off")
plt.show()

# Make prediction
test_sample = merged_images[test_id].reshape(1, 28, 56)
predictions = double_digit_model.predict(test_sample)

predicted_left_digit = np.argmax(predictions[0])
predicted_right_digit = np.argmax(predictions[1])

print("Predicted Digits:", predicted_left_digit, predicted_right_digit)
print("Actual Digits:", merged_labels_left[test_id], merged_labels_right[test_id])

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt

# Load MNIST dataset
(train_imgs, train_lbls), (test_imgs, test_lbls) = mnist.load_data()

# Normalize images
train_imgs = train_imgs.astype("float32") / 255.0
test_imgs = test_imgs.astype("float32") / 255.0

# Prepare combined images for training
combined_images = []
combined_labels = []

num_samples = 5000  # Number of combined samples

for i in range(num_samples):
    left_img = train_imgs[i]
    right_img = train_imgs[i + 1]

    combined_img = np.concatenate((left_img, right_img), axis=1)  # 28x56
    combined_images.append(combined_img)

    # Combine labels as string for reference
    combined_label = str(train_lbls[i]) + str(train_lbls[i + 1])
    combined_labels.append(combined_label)

combined_images = np.array(combined_images).reshape(-1, 28, 56, 1)
combined_labels_array = np.array(combined_labels)  # For display only

# Build neural network
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 56, 1)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(20, activation='softmax')  # 2 digits × 10 outputs
])

# Custom label processing: predict left and right digits separately
left_digit_labels = np.array([int(l[0]) for l in combined_labels])
right_digit_labels = np.array([int(l[1]) for l in combined_labels])

# One-hot encode labels for 10 classes each
left_onehot = tf.keras.utils.to_categorical(left_digit_labels, num_classes=10)
right_onehot = tf.keras.utils.to_categorical(right_digit_labels, num_classes=10)

# Combine into single output vector (20 neurons)
y_combined = np.concatenate([left_onehot, right_onehot], axis=1)

# Compile model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train model
model.fit(combined_images, y_combined, epochs=10, verbose=0)

# -------- User Input Section --------
user_input = input("Enter a two-digit number (e.g., 12, 31, 07): ")

# Ensure valid input
if len(user_input) != 2 or not user_input.isdigit():
    raise ValueError("Input must be exactly two digits between 0 and 9")

d1, d2 = int(user_input[0]), int(user_input[1])

# Find the first image of each digit from test set
idx1 = np.where(test_lbls == d1)[0][0]
idx2 = np.where(test_lbls == d2)[0][0]

img1 = test_imgs[idx1]
img2 = test_imgs[idx2]

# Combine images
test_combined = np.concatenate((img1, img2), axis=1).reshape(1, 28, 56, 1)

# Display combined image
plt.imshow(np.squeeze(test_combined), cmap='gray')
plt.title(f"Combined Digit Image: {d1}{d2}")
plt.axis('off')
plt.show()

# Predict
pred = model.predict(test_combined)

# Extract predicted digits
pred_left = np.argmax(pred[0][:10])
pred_right = np.argmax(pred[0][10:])

print("Predicted Digits:", f"{pred_left}{pred_right}")
print("Actual Digits:", f"{d1}{d2}")

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt

# Load MNIST dataset
(train_imgs, train_lbls), (test_imgs, test_lbls) = mnist.load_data()

# Normalize images
train_imgs = train_imgs.astype("float32") / 255.0
test_imgs = test_imgs.astype("float32") / 255.0

# Prepare combined images for training
combined_images = []
combined_labels = []

num_samples = 5000  # Number of combined samples

for i in range(num_samples):
    left_img = train_imgs[i]
    right_img = train_imgs[i + 1]

    combined_img = np.concatenate((left_img, right_img), axis=1)  # 28x56
    combined_images.append(combined_img)

    combined_label = str(train_lbls[i]) + str(train_lbls[i + 1])
    combined_labels.append(combined_label)

combined_images = np.array(combined_images).reshape(-1, 28, 56, 1)
combined_labels_array = np.array(combined_labels)

# Build neural network
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 56, 1)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(20, activation='softmax')  # 2 digits × 10 outputs
])

# Prepare training labels
left_digit_labels = np.array([int(l[0]) for l in combined_labels])
right_digit_labels = np.array([int(l[1]) for l in combined_labels])

left_onehot = tf.keras.utils.to_categorical(left_digit_labels, num_classes=10)
right_onehot = tf.keras.utils.to_categorical(right_digit_labels, num_classes=10)

y_combined = np.concatenate([left_onehot, right_onehot], axis=1)

# Compile and train model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.fit(combined_images, y_combined, epochs=10, verbose=0)

# -------- User Input Section --------
user_input = input("Enter any two-digit number (00 to 99): ")

# Ensure valid input
if len(user_input) != 2 or not user_input.isdigit():
    raise ValueError("Input must be exactly two digits between 0 and 9")

tens = int(user_input[0])
units = int(user_input[1])

# Find first MNIST test images for each digit
idx_tens = np.where(test_lbls == tens)[0][0]
idx_units = np.where(test_lbls == units)[0][0]

img_tens = test_imgs[idx_tens]
img_units = test_imgs[idx_units]

# Combine images horizontally
test_combined = np.concatenate((img_tens, img_units), axis=1).reshape(1, 28, 56, 1)

# Display combined image
plt.imshow(np.squeeze(test_combined), cmap='gray')
plt.title(f"Input Number: {user_input}")
plt.axis('off')
plt.show()

# Predict digits
pred = model.predict(test_combined)

pred_tens = np.argmax(pred[0][:10])
pred_units = np.argmax(pred[0][10:])

print("Predicted Number:", f"{pred_tens}{pred_units}")
print("Actual Number:", f"{tens}{units}")

import tensorflow as tf
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# Generate synthetic transaction dataset
transaction_data = {
    'txn_amount': np.random.randint(200, 15000, 1200),
    'txn_hour': np.random.randint(0, 24, 1200),
    'txn_region': np.random.randint(1, 6, 1200),
    'is_fraud': np.random.randint(0, 2, 1200)
}

dataset = pd.DataFrame(transaction_data)

# Separate features and target
features = dataset[['txn_amount', 'txn_hour', 'txn_region']]
labels = dataset['is_fraud']

# Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(
    features, labels, test_size=0.25, random_state=7
)

# Normalize features
scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Define feedforward neural network
fraud_model = tf.keras.Sequential([
    tf.keras.layers.Dense(12, activation='relu', input_shape=(3,)),
    tf.keras.layers.Dense(6, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Compile the model
fraud_model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.01),
    loss='binary_crossentropy',
    metrics=['accuracy']
)

# Train the model
fraud_model.fit(X_train, y_train, epochs=12, verbose=0)

# Take user input
amt = float(input("Enter transaction amount: "))
hour = float(input("Enter transaction hour (0–23): "))
region = float(input("Enter transaction region (1–5): "))

# Prepare input for prediction
input_transaction = np.array([[amt, hour, region]])
input_transaction = scaler.transform(input_transaction)

# Predict fraud likelihood
fraud_score = fraud_model.predict(input_transaction)[0][0]

# Display prediction
print("Fraud Score:", round(fraud_score, 4))
if fraud_score >= 0.5:
    print("Transaction Status: Fraudulent")
else:
    print("Transaction Status: Non-Fraudulent")

import tensorflow as tf
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt
# Load MNIST dataset
(X_train, y_train), _ = mnist.load_data()
# Combine two digits side by side
X_double = []
y_double = []
for i in range(5000):
    combined_image = np.hstack((X_train[i], X_train[i + 1]))
    X_double.append(combined_image)
    y_double.append(y_train[i])
X_double = np.array(X_double) / 255.0
y_double = np.array(y_double)
# Build neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 56)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])
# Compile model
model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)
# Train model
model.fit(X_double, y_double, epochs=10, verbose=0)
# User input
index = int(input("Enter an index value (0 to 4999): "))
# Display combined image
plt.imshow(X_double[index], cmap='gray')
plt.title("Combined Handwritten Digit Image")
plt.axis('off')
plt.show()
# Predict digit
sample = X_double[index].reshape(1, 28, 56)
prediction = model.predict(sample)
print("Predicted Digit:", np.argmax(prediction))
print("Actual Digit:", y_double[index])

"""# Task
Search through the `merged_labels_left` and `merged_labels_right` arrays to find an index where `merged_labels_left` is '1' and `merged_labels_right` is '2'. If found, display the index. If not found, indicate that such an image does not exist in the current dataset. Then, provide instructions to the user on how to enter the found index (if any) to see the '1 2' prediction, and reiterate the distinction between the input index and the predicted digit values.

## Search for specific digits

### Subtask:
Search through the `merged_labels_left` and `merged_labels_right` arrays to find an index where `merged_labels_left` is '1' and `merged_labels_right` is '2'. If found, display the index. If not found, indicate that such an image does not exist in the current dataset.

**Reasoning**:
The subtask requires iterating through the `merged_labels_left` and `merged_labels_right` arrays to find a specific digit combination and then printing the index if found, or a message if not found. A Python code block is suitable for this task.
"""

target_index = None

for i in range(len(merged_labels_left)):
    if merged_labels_left[i] == 1 and merged_labels_right[i] == 2:
        target_index = i
        break

if target_index is not None:
    print(f"Double-digit '12' image found at index: {target_index}")
else:
    print("Double-digit '12' image not found in the dataset.")

"""### Instructions to view the '12' prediction:

We found a '12' double-digit image at index **`3`** in our `merged_images` and `merged_labels` dataset.

To see how the `double_digit_model` predicts this specific image, you can use the `test_id` input field in the code cell where the model prediction is made. Please change the value in the input prompt to `3` and re-run that cell to visualize the '12' image and its prediction.

**Important Distinction:**
*   The **input index** (e.g., `3` in this case) refers to the position of the image within our generated `merged_images` dataset.
*   The **predicted digit values** (e.g., `1` and `2`) are the actual numbers that the neural network identified in the left and right halves of the image at that given index. The model will output these predicted digits after processing the image at the specified index.

## Final Task

### Subtask:
Provide instructions to the user on how to enter the found index (if any) to see the '1 2' prediction, and reiterate the distinction between the input index and the predicted digit values.

## Summary:

### Q&A
An index where `merged_labels_left` is '1' and `merged_labels_right` is '2' was found at index `3`.

### Data Analysis Key Findings
*   The search for an image with '1' in `merged_labels_left` and '2' in `merged_labels_right` was successful.
*   A double-digit '12' image was identified at index `3` in the dataset.

### Insights or Next Steps
*   To visualize the '12' prediction, users should input `3` into the `test_id` field of the `double_digit_model`'s prediction cell and re-execute it.
*   It is crucial to differentiate between the "input index" (the image's position in the dataset) and the "predicted digit values" (the numbers identified by the model within the image).
"""